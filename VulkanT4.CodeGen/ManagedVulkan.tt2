<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Collections.Specialized" #>
<#@ import namespace="VulkanT4" #>
<#@ assembly name="$(SolutionDir)Lib\VulkanT4.dll" #>
<#@ output extension=".cpp" #>
<#

var entitiesXml = "vk.xml";

var doc = XDocument.Load(Host.ResolvePath(entitiesXml), LoadOptions.PreserveWhitespace);

var generator = new VulkanT4.VkAPIGenerator();
generator.Apply(doc);

var ns = "ManagedVulkan";
#>
// This is the main DLL file.
#include <vulkan/vulkan.h>
#include "ManagedVulkan.h"

using namespace System.Collection.Generic;

<#	
	foreach (var proxy in generator.Proxies.Values)
	{
#>

// <#= proxy.Key #>
<#
		foreach (var m in proxy.Methods)
		{
			var returnType = m.Function.ReturnType ?? "<RETURN_TYPE>";
#>
<#= returnType #> <#= ns #>::<#= proxy.Name #>::<#= m.Name #>(<#
			var first = true;
			var separator = "";
			foreach(var param in m.Parameters)
			{ 
				var paramName = param.Name ?? "<NAME>";
				
				string paramType = "<TYPE>";

				if (param.Translation != null)
				{				
					if (param.UseOutStatement)
					{
						paramType = "out ";
						
						if (param.IsArray)
						{
							paramType += "array<" + param.Translation.CSharpType + ">^";
						}
						else
						{
							paramType += param.Translation.CSharpType;
						}
					}
					else
					{
						if (param.IsArray)
						{
							paramType = "array<" + param.Translation.CSharpType + ">^";
						}
						else
						{
							paramType = param.Translation.MethodOnly;
						}						
					}
				}
				else 
				{
					paramType = param.CSharpType ?? param.CppType ?? "<TYPE>";
				}
			#><#= separator #><#= paramType #> <#= paramName #><#
				if (first)
				{
					separator = ", ";
					first = false;
				}	
			} #>)
{
<#
			var declare = new VariableDeclaration();
			var commands = declare.Parse(m.Function);
			var lengths = new StringCollection();
#>
	List<IntPtr>^ pins = gcnew List<IntPtr>();
<#
			// ARRAY VARIABLES
			foreach(var param in m.Function.Parameters)
			{  
				string variableName = "arg_" + param.Index;
				string valueStmt = "nullptr";

				if (param.IsArray)
				{
#>
	<#= param.CppType #> <#= variableName #> = <#= valueStmt #>;
<#
				}
			}
#>
	try
	{
<#
// BEGIN -- FIRST C++ FUNCTION CALL
			bool makeSecondCall = (m.ArrayInfo != null && m.ArrayInfo.SecondCall);
			if (makeSecondCall)
			{
				var firstReturnStmt = (m.Function.ReturnType == "void") ? ""	: "var firstResult = ";	

				foreach(var command in commands)
				{ 		
					var param = command.Parameter;					
					if (param != null && command.MemberType != null)
					{
						string variableName = command.ArgumentName;

						if (lengths.Contains(command.Parameter.Name))
						{	
							command.IsInitialised = true;

							command.PriorStatements.Add("// " + param.Index + " - " + param.Name);
							command.PriorStatements.Add(command.MemberType.CSharpType + " " + param.Name);
							command.PriorStatements.Add(<command.MemberType.CSharpType + "* " + command.ArgumentName+ " = &" + param.Name);
	
						}
						else if (!command.Parameter.UseOutStatement)
						{

							string valueStmt = "0";

							if (param.Index == 0 && proxy.RequiresInstance)
							{
								valueStmt = "this->mHandle";
							}
							// IS METHOD PARAMETER A HANDLE => STRAIGHT COPY
							else if (param.Translation.HandleInfo != null)
							{
								valueStmt = param.Name + "->mHandle";
							}
							else if (param.Translation.EnumInfo != null)
							{
								valueStmt = param.Name;
							}

							command.IsInitialised = true;

							command.PriorStatements.Add("// " + param.Index + " - " + param.Name);

							if (param.IsArray)
							{
								var elementType = "<TYPE>";
								if (param.Translation != null)
								{
									if (param.Translation.StructInfo != null)
									{
										elementType = param.Translation.StructInfo.Key;
									}
									else if (param.Translation.HandleInfo != null)
									{
										elementType = param.Translation.HandleInfo.Key;
									}
									else if (param.Translation.ProxyInfo != null)
									{
										elementType = param.Translation.ProxyInfo.Key;
									}									
								}					
								command.PriorStatements.Add(variableName + " = new " + elementType + "[" + param.LengthConditions[0] + "]");
							}
							else
							{
								bool needCallVariable =
									param.Translation != null
									&& (
										param.Translation.StructInfo != null 
										|| param.Translation.HandleInfo != null
										|| param.Translation.ProxyInfo != null
									)	
									&&
									(
											(param.UseOutStatement)
										||  (!param.UseOutStatement && !proxy.RequiresInstance)	
										||  (!param.UseOutStatement && proxy.RequiresInstance && param.Index > 0 && !param.IsHandle())
									);						

								if (needCallVariable)
								{
									// NEED TO INITIALISE PINNED DATA
									var pinnedVariable = command.InstanceName;
									var pinnedType = param.CppType;

									if (param.Translation.StructInfo != null)
									{
										pinnedType = param.Translation.StructInfo.Key;
									}
									else if (param.Translation.HandleInfo != null)
									{
										pinnedType = param.Translation.HandleInfo.Key;
									}
									else if (param.Translation.ProxyInfo != null)
									{
										pinnedType = param.Translation.ProxyInfo.Key;
									}		
									valueStmt = "&" + pinnedVariable;																								
									command.PriorStatements.Add(pinnedType + "  " + pinnedVariable);					
								}
								else if (param.Translation.CSharpType == "String^")
								{
									command.PriorStatements.Add("IntPtr " + command.InstanceName + " = Marshal::StringToHGlobalAnsi(" + variableName + ")");
									command.PriorStatements.Add("pins->Add(" + command.InstanceName ")");
									valueStmt = "static_cast<char*>(" + command.InstanceName + ".ToPointer())";								
								}

								command.PriorStatements.Add(param.CppType + " " + variableName + " " + valueStmt + ";");
								if (param.Translation != null && param.Translation.StructInfo != null)
								{	
									command.PriorStatements.Add(param.Name + "->CopyTo(" + variableName + ");");
								}				
							}											
						}
					}
				}													
#>

		<#= firstReturnStmt #><#= m.Function.Key #>(<#
			first = true;
			separator = "";
				foreach(var command in commands)
				{ 	
					string variableName =  command.IsInitialised ? command.ArgumentName : "nullptr";

			#><#= separator #><#= variableName #><#
					if (first)
					{
						separator = ", ";
						first = false;
					}				
				} #>);
<#
				if (m.Function.ReturnType == "VkResult") 
				{
#>

		if (firstResult != VK_SUCCESS)
		{
			return firstResult;
		}

<#
				}
			}
// END -- FIRST C++ FUNCTION CALL
#>
<#
// BEGIN -- C++ ARGUMENT INITIALISATION
			foreach(var command in commands)	
			{ 
				var param = command.Parameter;
				if (param == null)
				{
					continue;
				}

				if (command.IsInitialised)
				{
					continue;
				}

				string variableName = command.ArgumentName;
				string valueStmt = "0";

				if (param.Index == 0 && proxy.RequiresInstance)
				{
					valueStmt = "this->mHandle";
				}
				// IS METHOD PARAMETER A HANDLE => STRAIGHT COPY
				else if (param.Translation != null && param.Translation.HandleInfo != null)
				{
					valueStmt = param.Name + "->mHandle";
				}
				else if (param.Translation != null && param.Translation.EnumInfo != null)
				{
					valueStmt = param.Name;
				}
#>
		// <#= param.Index #> - <#= param.Name #>
<#
				if (param.IsArray)
				{
					var elementType = "<TYPE>";
					if (param.Translation != null)
					{
						if (param.Translation.StructInfo != null)
						{
							elementType = param.Translation.StructInfo.Key;
						}
						else if (param.Translation.HandleInfo != null)
						{
							elementType = param.Translation.HandleInfo.Key;
						}
						else if (param.Translation.ProxyInfo != null)
						{
							elementType = param.Translation.ProxyInfo.Key;
						}		
					}					
#>
		<#= variableName #> = new <#= elementType#>[<#= param.LengthConditions[0] #>];
<#
				}
				else
				{
					bool needCallVariable =
						param.Translation != null
						&& (
							param.Translation.StructInfo != null 
							|| param.Translation.HandleInfo != null
							|| param.Translation.ProxyInfo != null
						)	
						&&
						(
								(param.UseOutStatement)
							||  (!param.UseOutStatement && !proxy.RequiresInstance)	
							||  (!param.UseOutStatement && proxy.RequiresInstance && param.Index > 0 && param.Translation.HandleInfo == null)				   
						);
						

					if (needCallVariable)
					{
						// NEED TO INITIALISE PINNED DATA
						var pinnedVariable = command.InstanceName;
						var pinnedType = param.CppType;

						if (param.Translation.StructInfo != null)
						{
							pinnedType = param.Translation.StructInfo.Key;
						}
						else if (param.Translation.HandleInfo != null)
						{
							pinnedType = param.Translation.HandleInfo.Key;
						}
						else if (param.Translation.ProxyInfo != null)
						{
							pinnedType = param.Translation.ProxyInfo.Key;
						}		
#>		<#= pinnedType #> <#= pinnedVariable #>;
<#					
						valueStmt = "&" + pinnedVariable;			
					}
#>
		<#= param.CppType #> <#= variableName #> = <#= valueStmt #>;
<#
// BEGIN -- PARAMETER COPY TO INSTANCE
					if (param.Translation != null && param.Translation.StructInfo != null)
					{
#>
		<#= param.Name #>->CopyTo(<#= variableName #>);
<#						
					}					
// END -- PARAMETER COPY TO INSTANCE
				}
			}		
// END -- C++ ARGUMENT INITIALISATION
#>

<#
// BEGIN -- C++ FUNCTION CALL
			var callReturnStmt = (m.Function.ReturnType == "void") ? ""	: "var result = ";			
#>
		<#= callReturnStmt #><#= m.Function.Key #>(<#
			first = true;
			separator = "";
			foreach(var param in m.Function.Parameters)
			{ 
				string variableName = "arg_" + param.Index;

			#><#= separator #><#= variableName #><#
				if (first)
				{
					separator = ", ";
					first = false;
				}
			} #>);
<#
// END -- C++ FUNCTION CALL
#>

<#	
// BEGIN -- OUT PARAMETER INITIALISATION
			foreach(var param in m.Parameters)
			{ 
				var paramType = "<TYPE>";
				var paramValue = "";

				if (param.UseOutStatement && param.Translation != null)
				{
					if (param.IsArray)
					{
						paramType = "array<" + param.Translation.CSharpType + ">^";
						paramValue = "count";
#>			
		int count = <#= param.LengthConditions[0] #>;	
		<#= param.Name #> = gcnew <#= paramType #>(<#= paramValue #>);
		for	(int i = 0; i < count; ++i)
		{	
			<#= param.Name #>[i] = gcnew <#= param.Translation.CSharpType #>();	
			<#= param.Name #>[i]->CopyFrom(arg_<#= param.Index #>[i]);
		}	
<#

					}
					else
					{
						paramType = param.Translation.CSharpType;
#>								
		<#= param.Name #> = gcnew <#= paramType #>(<#= paramValue #>);
<#
//  BEGIN - SET INTERNAL HANDLE INST MEMBER
						if (param.Translation.ProxyInfo != null || param.Translation.HandleInfo != null)
						{
							var pinnedVariable = "inst_" + param.Index;
#>
		<#= param.Name #>->mHandle = <#= pinnedVariable #>;
<#
						}
	//  END - SET INTERNAL HANDLE INST MEMBER

	//  BEGIN - OUT SINGLE LEVEL COPY FROM
						else if (param.Translation.StructInfo != null)
						{
							string variableName = "arg_" + param.Index;
#>
			<#= param.Name #>->CopyFrom(<#= variableName #>);						
<#
						}
					}
	//  END - OUT SINGLE LEVEL COPY FROM
				}
			}
// END --  OUT PARAMETER INITIALISATION
#>

<#
// BEGIN -- FINAL RETURN STATEMENT
			var finalReturnStmt = ""; // VOID 
			if (m.Function.ReturnType == "VkBool32") 
			{
				finalReturnStmt = "return result != 0;";
			}
			else if (m.Function.ReturnType != "void")		
			{
				finalReturnStmt = "return (" + m.Function.ReturnType + ") result;"; 
			}
#>
		<#= finalReturnStmt #>
<# 
// END --  FINAL RETURN STATEMENT
#>
	}
	finally
	{
<#
// BEGIN -- DELETE ARRAY VARIABLES
			for(int i =0; i < m.Function.Parameters.Count; ++i)
			{ 
				var param = m.Function.Parameters[i];
				string variableName = "arg_" + i;

				if (param.IsArray)
				{
#>
		if (<#= variableName #> != nullptr)
		{
			delete[] <#= variableName #>;
		}
<#
				}
			}
// END -- DELETE ARRAY VARIABLES
#>
		// FREE ALL PINNED STRINGS
		foreach(var str in pins)
		{
			Marshal::FreeHGlobal(str);
		}
	}
}

<#
		}
	}
#>
